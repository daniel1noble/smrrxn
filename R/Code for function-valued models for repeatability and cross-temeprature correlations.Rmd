---
title: "Code for running function-valued models using MCMCglmm to estimate repeatability and cross-temperature correlations"
author: "Fonti Kar"
date: "07/12/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, include = T)
rm(list=ls())
sessionInfo()
#R version 3.4.2 (2017-09-28)
#Platform: x86_64-apple-darwin15.6.0 (64-bit)
#Running under: macOS High Sierra 10.13.6

packages.need <- c("ggplot2", "corrplot", "tidyverse", "dplyr", "magrittr", "MCMCglmm", "brms")
lapply(packages.need, require, character.only = TRUE)
```

The code below is uses a function-valued approach in the MCMCglmm package to calculate: 
a) adjusted repeatability (sensu Nakagawa & Schielzeth, 2010) of VCO2 at each measurement temperature 
b) short- and long-term adjusted repeatability (sensu Araya-Ajoy et al 2015) of VCO2 at each measurement temperature 
c) cross-temperature correlation (sensu Brommer 2013) of VCO2 between each measurement temperature at the among- and within-individual-among-sampling-session level

## Read in long format data first and load helper functions

```{r load data}
data <- read.csv("R/RMDs/Long_data_for_analysis.csv")
str(data)
dim(data)

source("R/functions/unpacking.R")
source("R/functions/smr_functions.R")
```

## Thermal repeatability of VCO2 (i.e. repeatability of intercept, mean centered to each temperature)

For more details see: Araya-Ajoy, Y. G., Mathot, K. J., & Dingemanse, N. J. (2015). An approach to estimate short-term, long-term and reaction norm repeatability, 6(12), 1462???1473. http://doi.org/10.1111/2041-210X.12430

###Priors, and model set up for all FV repeatability models

```{r}
#Priors
expanded.prior <- list(R = list(V = 1, nu = 0.002),
                       G = list(G1 = list(V = diag(2), nu = 0.002, alpha.V = diag(1000,2,2), alpha.mu = rep(0,2)),
                                G2 = list(V = diag(2), nu = 0.002, alpha.V = diag(1000,2,2), alpha.mu = rep(0,2))))

#Number of iterations, burn in and thinning interval
nitt = 7510000
burnin = 10000
thin = 5000
```

### Intercept at log(22??C)

```{r Yimen T22}
mod1.22 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp_22cen + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp_22cen):id + us(1+log.temp_22cen):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.22, "output/RMD_output/rds/modc.t22")

#Read in model output and pool chains
modc.t22 <- readRDS("R/RMDs/output/modc.t22")
modc.t22.Sol <- Sol.unpack("R/RMDs/output/modc.t22")
modc.t22.VCV <- VCV.unpack("R/RMDs/output/modc.t22")

#Diagnostics
Sol.check("R/RMDs/output/modc.t22")
VCV.check("R/RMDs/output/modc.t22")

#Repeatability of interept and its credible intervals (equation 2):
FV.rpt.Int.mean(modc.t22.VCV)

#Short- and long-term repeatability of interept and its credible intervals (equation 4 & 5):
FV.rpt.Int.short.mean(modc.t22.VCV)
FV.rpt.Int.long.mean(modc.t22.VCV)
```

### Intercept at log(24??C)
```{r}
mod1.24 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp_24cen + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp_24cen):id + us(1+log.temp_24cen):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.24, "output/RMD_output/rds/modc.t24")

#Read in model output and pool chains
modc.t24 <- readRDS("R/RMDs/output/modc.t24")
modc.t24.Sol <- Sol.unpack("R/RMDs/output/modc.t24")
modc.t24.VCV <- VCV.unpack("R/RMDs/output/modc.t24")

#Diagnostics
Sol.check("R/RMDs/output/modc.t24")
VCV.check("R/RMDs/output/modc.t24")

#Repeatability of interept and its credible intervals (equation 2):
FV.rpt.Int.mean(modc.t24.VCV)

#Short- and long-term repeatability of interept and its credible intervals (equation 4 & 5):
FV.rpt.Int.short.mean(modc.t24.VCV)
FV.rpt.Int.long.mean(modc.t24.VCV)
```

### Intercept at log(26??C)
```{r}
mod1.26 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp_26cen + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp_26cen):id + us(1+log.temp_26cen):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.26, "output/RMD_output/rds/modc.t26")

#Read in model output and pool chains
modc.t26 <- readRDS("R/RMDs/output/modc.t26")
modc.t26.Sol <- Sol.unpack("R/RMDs/output/modc.t26")
modc.t26.VCV <- VCV.unpack("R/RMDs/output/modc.t26")

#Diagnostics
Sol.check("R/RMDs/output/modc.t26")
VCV.check("R/RMDs/output/modc.t26")

#Repeatability of interept and its credible intervals (equation 2):
FV.rpt.Int.mean(modc.t26.VCV)

#Short- and long-term repeatability of interept and its credible intervals (equation 4 & 5):
FV.rpt.Int.short.mean(modc.t26.VCV)
FV.rpt.Int.long.mean(modc.t26.VCV)
```

### Intercept at log(28??C)
```{r}
mod1.28 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp_28cen + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp_28cen):id + us(1+log.temp_28cen):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.28, "output/RMD_output/rds/modc.t28")

#Read in model output and pool chains
modc.t28 <- readRDS("R/RMDs/output/modc.t28")
modc.t28.Sol <- Sol.unpack("R/RMDs/output/modc.t28")
modc.t28.VCV <- VCV.unpack("R/RMDs/output/modc.t28")

#Diagnostics
Sol.check("R/RMDs/output/modc.t28")
VCV.check("R/RMDs/output/modc.t28")

#Repeatability of interept and its credible intervals (equation 2):
FV.rpt.Int.mean(modc.t28.VCV)

#Short- and long-term repeatability of interept and its credible intervals (equation 4 & 5):
FV.rpt.Int.short.mean(modc.t28.VCV)
FV.rpt.Int.long.mean(modc.t28.VCV)
```

### Intercept at log(30??C)
```{r}
mod1.30 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp_30cen + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp_30cen):id + us(1+log.temp_30cen):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.30, "output/RMD_output/rds/modc.t30")

#Read in model output and pool chains
modc.t30 <- readRDS("R/RMDs/output/modc.t30")
modc.t30.Sol <- Sol.unpack("R/RMDs/output/modc.t30")
modc.t30.VCV <- VCV.unpack("R/RMDs/output/modc.t30")

#Diagnostics
Sol.check("R/RMDs/output/modc.t30")
VCV.check("R/RMDs/output/modc.t30")

#Repeatability of interept and its credible intervals (equation 2):
FV.rpt.Int.mean(modc.t30.VCV)

#Short- and long-term repeatability of interept and its credible intervals (equation 4 & 5):
FV.rpt.Int.short.mean(modc.t30.VCV)
FV.rpt.Int.long.mean(modc.t30.VCV)
```

### Intercept at log(32??C)
```{r}
mod1.32 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp_32cen + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp_32cen):id + us(1+log.temp_32cen):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.32, "output/RMD_output/rds/modc.t32")

#Read in model output and pool chains
modc.t32 <- readRDS("R/RMDs/output/modc.t32")
modc.t32.Sol <- Sol.unpack("R/RMDs/output/modc.t32")
modc.t32.VCV <- VCV.unpack("R/RMDs/output/modc.t32")

#Diagnostics
Sol.check("R/RMDs/output/modc.t32")
VCV.check("R/RMDs/output/modc.t32")

#Repeatability of interept and its credible intervals (equation 2):
FV.rpt.Int.mean(modc.t32.VCV)

#Short- and long-term repeatability of interept and its credible intervals (equation 4 & 5):
FV.rpt.Int.short.mean(modc.t32.VCV)
FV.rpt.Int.long.mean(modc.t32.VCV)
```

### Thermal repeatability using the covariance of the intercept and slope

This method derives repeatability at each measurements using the variance-covaraince of the intercept and slope following: 

Note that samp_period is treated as a fixed predictor because, to the best of our knowledge, this method has not been extended to multiple random effects. As a consequence, the prior structure is different for this model
```{r}
#Number of iterations, burn in and thinning interval
cond.expanded.prior <- list(R = list(V = 1, nu = 0.002),
                       G = list(G1 = list(V = diag(2), nu = 0.002, alpha.V = diag(1000,2,2), alpha.mu = rep(0,2))))

mod1.conditional <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp + z.log.mass + log.prior_temp + samp_period,
           random = ~us(1+log.temp):id,
           family = "gaussian",
           prior = cond.expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)

#saveRDS(mod1.conditional, "output/RMD_output/rds/mod1.conditional")

#Read in model output and pool chains
mod1.conditional <- readRDS("R/RMDs/output/mod1.conditional")
mod1.conditional.Sol <- Sol.unpack("R/RMDs/output/mod1.conditional")
mod1.conditional.VCV <- VCV.unpack("R/RMDs/output/mod1.conditional")

#Diagnostics
Sol.check("R/RMDs/output/mod1.conditional")
VCV.check("R/RMDs/output/mod1.conditional")

#Condtional repeatability at each measurement and its credible intervals (equation 6):
SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(22))
SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(24))
SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(26))
SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(28))
SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(30))
SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(32))
```

### Intercept at log.temp = 0 (i.e 1C)

This model is used for calculating the repeatability of the slope (see  Araya-Ajoy et al 2015), as well as the cross-temperature correlations using the FV approach (see below)

```{r}
mod1.0 <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp):id + us(1+log.temp):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           verbose = T)
}, mc.cores = 3)
  
#saveRDS(mod1.0, "output/RMD_output/rds/modc.t0")

#Read in model output and pool chains
mod1.0 <- readRDS("R/RMDs/output/mod1.0")
mod1.0.Sol <- Sol.unpack("R/RMDs/output/mod1.0")
mod1.0.VCV <- VCV.unpack("R/RMDs/output/mod1.0")

#Diagnostics
Sol.check("R/RMDs/output/mod1.0")
VCV.check("R/RMDs/output/mod1.0")

#Calculating the repeatability of slope and credible intervals
rpt.Slope.mean(mod1.0.VCV, "log.temp:log.temp.id", "log.temp:log.temp.series")
```

### Model with intercept at log.temp = 0 (i.e 1C) and estimating BLUPS for each individual. This model is use for generating model predicted reaction norms

```{r}
mod1.0.BLUP <- mclapply(1:3, function(i) {
  MCMCglmm(log.co2pmin ~ log.temp + z.log.mass + log.prior_temp,
           random = ~us(1+log.temp):id + us(1+log.temp):series,
           family = "gaussian",
           prior = expanded.prior,
           nitt = nitt,
           burnin = burnin,
           thin = thin,
           data = data, 
           pr = T,
           verbose = T)
}, mc.cores = 3)

saveRDS(mod1.0.BLUP , "R/mod1.0.BLUP")

#Read in model output and pool chains
mod1.0.BLUP <- readRDS("R/RMDs/output/mod1.0.BLUP")
mod1.0.BLUP.Sol <- Sol.unpack("R/RMDs/output/mod1.0.BLUP")
mod1.0.BLUP.VCV <- VCV.unpack("R/RMDs/output/mod1.0.BLUP")

#Diagnostics
Sol.check("R/RMDs/output/mod1.0.BLUP")
VCV.check("R/RMDs/output/mod1.0.BLUP")

```


### Code to derive cross-temperature correlations
For more details see: Brommer, J. E. (2013). Variation in plasticity of personality traits implies that the ranking of personality measures changes between environmental contexts: calculating the cross-environmental correlation. Behavioral Ecology and Sociobiology, 67(10), 1709???1718. http://doi.org/10.1007/s00265-013-1603-9
```{r}
#The code below uses the same model as the model for calculating the repeatability of the slope (mod1.0) 
#Read in model output and pool chains
mod1.0 <- readRDS("R/RMDs/output/mod1.0")
mod1.0.Sol <- Sol.unpack("R/RMDs/output/mod1.0")
mod1.0.VCV <- VCV.unpack("R/RMDs/output/mod1.0")

#Diagnostics
Sol.check("R/RMDs/output/mod1.0")
VCV.check("R/RMDs/output/mod1.0")

#Among ID cross-temperature correlations

#Among ID VCV matrix - equation 10
varcomps <- colMeans(mod1.0.VCV)
id_locations <- grep("id", colnames(mod1.0.VCV))
id.K <- matrix(varcomps[id_locations], nrow = 2, ncol = 2)

#Phi matrix - 'Design matrix', same for Among ID and Within ID, among sampling sessions - equation 11
log.temps <- sort(unique(data$log.temp))
phi <- matrix(c(rep(1, 6), log.temps), ncol = 2, nrow = 6) 

#P matrix - Among ID phenotypic covariances - equation 12
id.P <- phi%*%id.K%*%t(phi)
colnames(id.P) <- seq(22,32, by = 2)
rownames(id.P) <- seq(22,32, by = 2)

#Convert to correlations
cov2cor(id.P) 

#Generate credible intervals for Among ID cross-temperature correlations using every iteration from the model
#As a guide: 
#V_t22 = variance at 22??C
#r_22_24 = correlation between 22??C and 24??C

#Set up dataframe to population
id.cor.dat <-data.frame(V_t22 = numeric(),V_t24 = numeric(),V_t26 = numeric(), V_t28 = numeric(), V_t30 = numeric(), V_t32 = numeric(),
                      r_22_24 = numeric(), r_22_26 = numeric(), r_22_28 = numeric(), r_22_30 = numeric(), r_22_32 = numeric(),
                      r_24_26 = numeric(), r_24_28 = numeric(), r_24_30 = numeric(), r_24_32 = numeric(),
                      r_26_28 = numeric(), r_26_30 = numeric(), r_26_32 = numeric(),
                      r_28_30 = numeric(), r_28_32 = numeric(),
                      r_30_32 = numeric())


for (i in 1:length(mod1.0.VCV[,1])){
  phi <- matrix(c(rep(1, 6), log.temps), ncol = 2, nrow = 6) 
  id.K = matrix(mod1.0.VCV[i,1:4],2,2) #K matrix for the i'th iteration
  P <- phi%*%id.K%*%t(phi)  #apply the relevant calculations for 
  tmp <- data.frame(V_t22 = P[1,1], V_t24 = P[2,2], V_t26 = P[3,3], V_t28 = P[4,4], V_t30 = P[5,5], V_t32 = P[6,6],
                    r_22_24 = P[1,2]/sqrt(P[1,1]*P[2,2]), r_22_26 = P[1,3]/sqrt(P[1,1]*P[3,3]), r_22_28 = P[1,4]/sqrt(P[1,1]*P[4,4]),
                    r_22_30 = P[1,5]/sqrt(P[1,1]*P[5,5]), r_22_32 = P[1,6]/sqrt(P[1,1]*P[6,6]),
                    r_24_26 = P[2,3]/sqrt(P[2,2]*P[3,3]), r_24_28 = P[2,2]/sqrt(P[2,2]*P[4,4]), r_24_30 = P[2,2]/sqrt(P[2,2]*P[5,5]), r_24_32 =P[2,2]/sqrt(P[2,2]*P[6,6]),
                    r_26_28 = P[3,4]/sqrt(P[3,3]*P[4,4]), r_26_30 = P[3,5]/sqrt(P[3,3]*P[5,5]), r_26_32 = P[3,6]/sqrt(P[3,3]*P[6,6]),
                    r_28_30 = P[4,5]/sqrt(P[4,4]*P[5,5]), r_28_32 = P[4,6]/sqrt(P[4,4]*P[6,6]),
                    r_30_32 = P[5,5]/sqrt(P[5,5]*P[6,6]))
  id.cor.dat <-rbind(id.cor.dat, tmp)     #store the data
} 

#Posterior mean and CIs
Table3a <- posterior_summary(as.matrix(id.cor.dat))[7:21,c(1,3:4)]
#write.csv(round(Table3a,2), "R/RMDs/output/tabs/Table3a.csv")

#Within ID, among sampling sessions cross-temperature correlations i.e. series

#Within ID, among sampling sessions VCV matrix
series_locations <- grep("series", colnames(mod1.0.VCV))
series.K <- matrix(varcomps[series_locations], nrow = 2, ncol = 2) 

#P matrix - Within ID, among sampling sessions covariances - equation 12
series.P <- phi%*%series.K%*%t(phi)
colnames(series.P) <- seq(22,32, by = 2)
rownames(series.P) <- seq(22,32, by = 2)

#Convert to correlations
cov2cor(series.P) 

#Generate credible intervals for Within ID, among sampling sessions cross-temperature correlations using every iteration from the model
#As a guide: 
#V_t22 = variance at 22??C
#r_22_24 = correlation between 22??C and 24??C
#Set up dataframe to population
series.cor.dat <-data.frame(V_t22 = numeric(),V_t24 = numeric(),V_t26 = numeric(), V_t28 = numeric(), V_t30 = numeric(), V_t32 = numeric(),
                      r_22_24 = numeric(), r_22_26 = numeric(), r_22_28 = numeric(), r_22_30 = numeric(), r_22_32 = numeric(),
                      r_24_26 = numeric(), r_24_28 = numeric(), r_24_30 = numeric(), r_24_32 = numeric(),
                      r_26_28 = numeric(), r_26_30 = numeric(), r_26_32 = numeric(),
                      r_28_30 = numeric(), r_28_32 = numeric(),
                      r_30_32 = numeric())


for (i in 1:length(mod1.0.VCV[,1])){
  phi <- matrix(c(rep(1, 6), log.temps), ncol = 2, nrow = 6) 
  series.K = matrix(mod1.0.VCV[i,5:8],2,2) #K matrix for the i'th iteration
  P <- phi%*%series.K%*%t(phi)  #apply the relevant calculations for 
  tmp <- data.frame(V_t22 = P[1,1], V_t24 = P[2,2], V_t26 = P[3,3], V_t28 = P[4,4], V_t30 = P[5,5], V_t32 = P[6,6],
                    r_22_24 = P[1,2]/sqrt(P[1,1]*P[2,2]), r_22_26 = P[1,3]/sqrt(P[1,1]*P[3,3]), r_22_28 = P[1,4]/sqrt(P[1,1]*P[4,4]),
                    r_22_30 = P[1,5]/sqrt(P[1,1]*P[5,5]), r_22_32 = P[1,6]/sqrt(P[1,1]*P[6,6]),
                    r_24_26 = P[2,3]/sqrt(P[2,2]*P[3,3]), r_24_28 = P[2,2]/sqrt(P[2,2]*P[4,4]), r_24_30 = P[2,2]/sqrt(P[2,2]*P[5,5]), r_24_32 =P[2,2]/sqrt(P[2,2]*P[6,6]),
                    r_26_28 = P[3,4]/sqrt(P[3,3]*P[4,4]), r_26_30 = P[3,5]/sqrt(P[3,3]*P[5,5]), r_26_32 = P[3,6]/sqrt(P[3,3]*P[6,6]),
                    r_28_30 = P[4,5]/sqrt(P[4,4]*P[5,5]), r_28_32 = P[4,6]/sqrt(P[4,4]*P[6,6]),
                    r_30_32 = P[5,5]/sqrt(P[5,5]*P[6,6]))
  series.cor.dat <-rbind(series.cor.dat, tmp)     #store the data
} 

Table3b <- posterior_summary(as.matrix(series.cor.dat))[7:21,c(1,3:4)] #Notice there are correlation values greater than 1 (suggests that P matrix is not positive definite)
#write.csv(round(Table3b,2), "R/RMDs/output/tabs/Table3b.csv")
```

### Code to generate Table 1 and 2

```{r}
#Code to generate Table 1A
Table1a <- data.frame(matrix(nrow = 6, ncol = 10))
colnames(Table1a) <- c("Temperature", "R_int", "R_int_L", "R_int_U", 
                       "R_short", "R_short_L", "R_short_U", 
                       "R_long", "R_long_L", "R_long_U")
Table1a$Temperature <- seq(22,32, by = 2)

#R_int
#Read in model output and pool chains
modc.t22.VCV <- VCV.unpack("R/RMDs/output/modc.t22")
modc.t24.VCV <- VCV.unpack("R/RMDs/output/modc.t24")
modc.t26.VCV <- VCV.unpack("R/RMDs/output/modc.t26")
modc.t28.VCV <- VCV.unpack("R/RMDs/output/modc.t28")
modc.t30.VCV <- VCV.unpack("R/RMDs/output/modc.t30")
modc.t32.VCV <- VCV.unpack("R/RMDs/output/modc.t32")

#Temperature = 22
Table1a[1,2:4] <- round(FV.rpt.Int.mean(modc.t22.VCV),2)
Table1a[1,5:7] <- round(FV.rpt.Int.short.mean(modc.t22.VCV),2)
Table1a[1,8:10] <- round(FV.rpt.Int.long.mean(modc.t22.VCV),2)

#Temperature = 24
Table1a[2,2:4] <- round(FV.rpt.Int.mean(modc.t24.VCV),2)
Table1a[2,5:7] <- round(FV.rpt.Int.short.mean(modc.t24.VCV),2)
Table1a[2,8:10] <- round(FV.rpt.Int.long.mean(modc.t24.VCV),2)

#Temperature = 26
Table1a[3,2:4] <- round(FV.rpt.Int.mean(modc.t26.VCV),2)
Table1a[3,5:7] <- round(FV.rpt.Int.short.mean(modc.t26.VCV),2)
Table1a[3,8:10] <- round(FV.rpt.Int.long.mean(modc.t26.VCV),2)

#Temperature = 28
Table1a[4,2:4] <- round(FV.rpt.Int.mean(modc.t28.VCV),2)
Table1a[4,5:7] <- round(FV.rpt.Int.short.mean(modc.t28.VCV),2)
Table1a[4,8:10] <- round(FV.rpt.Int.long.mean(modc.t28.VCV),2)

#Temperature = 30
Table1a[5,2:4] <- round(FV.rpt.Int.mean(modc.t30.VCV),2)
Table1a[5,5:7] <- round(FV.rpt.Int.short.mean(modc.t30.VCV),2)
Table1a[5,8:10] <- round(FV.rpt.Int.long.mean(modc.t30.VCV),2)

#Temperature = 32
Table1a[6,2:4] <- round(FV.rpt.Int.mean(modc.t32.VCV),2)
Table1a[6,5:7] <- round(FV.rpt.Int.short.mean(modc.t32.VCV),2)
Table1a[6,8:10] <- round(FV.rpt.Int.long.mean(modc.t32.VCV),2)

#write.csv(Table1a, row.names = F, "output/Table1a.csv")
```
###Code to generate Figure 2A, Fig 3A, Fig 4 (Top panel)
```{r}
#Theme for all ggplots
my_theme <- theme_bw() + 
  theme(legend.position = "none", 
        legend.text = element_text(size = 12),
        legend.title = element_text(size = 12),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.text=element_text(size=14),
        axis.title=element_text(size=18),
        strip.text =element_text(size=18)) 

#Compile data for Fig 2A  to compare repeatability of different methods
rpt.plot.dat <- as.data.frame(matrix(ncol = 5, nrow = 18))
colnames(rpt.plot.dat) <- c("Approach", "Temperature", "Repeatability","lower", "upper")
rpt.plot.dat[,1] <- rep(c("FV - Yimen", "FV - Singer & Willet", "CS"), each = 6)
rpt.plot.dat[,2] <- rep(c(seq(22,32, by = 2)), 3)

#FV - 'Intercept' repeatability
rpt.plot.dat[1:6,3:5] <- rbind(FV.rpt.Int.long.mean(modc.t22.VCV),
                               FV.rpt.Int.long.mean(modc.t24.VCV),
                               FV.rpt.Int.long.mean(modc.t26.VCV),
                               FV.rpt.Int.long.mean(modc.t28.VCV),
                               FV.rpt.Int.long.mean(modc.t30.VCV),
                               FV.rpt.Int.long.mean(modc.t32.VCV))

#FV - condition repeatability
rpt.plot.dat[7:12,3:5] <- rbind(SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(22)),
                                SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(24)),
                                SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(26)),
                                SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(28)),
                                SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(30)),
                                SW.rpt.Temp.mean(mod1.conditional.VCV, temp = log(32)))

#CS tab
cs_mvmod <- readRDS("R/RMDs/output/cs_mvmod")
rpt.plot.dat[13:18,3:5] <- rbind(brms_rpt(cs_mvmod, temp = 22)[c(1,3,4)],
                                 brms_rpt(cs_mvmod, temp = 24)[c(1,3,4)],
                                 brms_rpt(cs_mvmod, temp = 26)[c(1,3,4)],
                                 brms_rpt(cs_mvmod, temp = 28)[c(1,3,4)],
                                 brms_rpt(cs_mvmod, temp = 30)[c(1,3,4)],
                                 brms_rpt(cs_mvmod, temp = 32)[c(1,3,4)])


ggplot(data = rpt.plot.dat, aes(x = Temperature, y = Repeatability, group = Approach, colour = Approach)) +
  geom_point(aes(color = Approach, shape = Approach), size = 4, position = position_dodge(1.5)) + 
  scale_shape_manual(values= c(16, 1, 16)) + 
  geom_errorbar(aes(ymin = lower, ymax = upper),width = 0, position = position_dodge(1.5), alpha = 1) +
  scale_color_manual(values=c("#159FEC","#E66726", "#E66726")) + 
  scale_x_continuous(breaks = c(22, 24, 26, 28, 30, 32)) + 
  ylim(0, 0.45) + 
  #scale_y_continuous(label = c(0.25, 0.5, 0.75, 1)) +
  labs(y = expression("Repeatability"), x = expression(paste("Temperature ",degree,"C"))) +
    my_theme

#Fig 3A Reaction norms character state approach
mod1.0.BLUP.Sol <- Sol.unpack("R/RMDs/output/mod1.0.BLUP")
mod1.0.BLUP.VCV <- VCV.unpack("R/RMDs/output/mod1.0.BLUP")

# Here are the six incubator temperatures, 
temps <- unique(data$log.temp)

#and the 42 lizard names
ids <- data$id %>% as.character %>% unique %>% sort

output <- do.call("rbind", lapply(1:10, function(i){
do.call("rbind", lapply(ids, log.T.get.predictions, post=cbind(mod1.0.BLUP.Sol, mod1.0.BLUP.VCV), sampling.period = i)) %>% 
    mutate(sampling.period = i) %>%
    arrange(Temperature, predicted) %>% 
    mutate(Lizard = factor(Lizard, levels = unique(Lizard)))
}))

#saveRDS(output, "R/RMDs/output/mod1.0.BLUP.predictions.csv")
output <- readRDS("R/RMDs/output/mod1.0.BLUP.predictions.csv")

#Plotting reaction norms for sample period 1,5,10
reaction.norms <- output %>% group_by(Temperature, Lizard, sampling.period) %>% 
  summarise(posterior.mean = mean(as.mcmc(predicted)), 
            lower = as.numeric(HPDinterval(as.mcmc(predicted)))[1], 
            upper = as.numeric(HPDinterval(as.mcmc(predicted)))[2])

slope.plot.dat <- reaction.norms %>% filter(sampling.period %in% c(1,5,10)) %>% as.data.frame()
slope.plot.dat <- mutate(slope.plot.dat, mr = posterior.mean, Temperature = exp(Temperature))

#Plot of reaction norms at sampling period 1, 5, 10 and show slopes are repeatable over time
#pdf("output/fig/pT/repeatability_of_slope.pdf", 12,9)
colfunc <- colorRampPalette(c("#159FEC", "#E66726"))
colfunc(42)
plot(rep(1,42),col=colfunc(42),pch=19,cex=3)

slope.plot.dat %>% 
  ggplot(aes(x = Temperature, y = mr, color = Lizard)) + 
  geom_point(shape = 1, fill = "white", size = 1, color = "black") + 
  geom_line(aes(group = Lizard, colour = Lizard), stat="smooth", method = "lm", alpha = 0.7) +
  scale_x_continuous(breaks = c(22, 24, 26, 28, 30, 32)) + 
  scale_color_manual(values = colfunc(42)) +
  facet_wrap(~ sampling.period) + 
  labs(x = expression(paste("Temperature ",degree,"C")), y = expression(~Log~metabolic~rate~(VCO[2]))) + 
    my_theme

#Fig 4 Cross Temperature correlations function-valued approach
#Among ID
cex.before <- par("cex")
par(cex = 1.2)
corrplot.mixed(as.matrix(cov2cor(id.P)), 
               lower.col = "black", upper = "ellipse", 
               tl.col = "black",tl.cex = par("cex"))
par(cex = cex.before)

#Within ID Among sampling session correlations
cex.before <- par("cex")
par(cex = 1.2)
corrplot.mixed(as.matrix(cov2cor(series.P)), 
               lower.col = "black", upper = "ellipse", 
               tl.col = "black", 
               tl.cex = par("cex"))
par(cex = cex.before)
```

